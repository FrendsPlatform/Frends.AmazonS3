using Amazon;
using Amazon.S3;
using Amazon.S3.Model;
using Frends.AmazonS3.UploadObject.Definitions;
using Frends.AmazonS3.UploadObject.Helpers;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace Frends.AmazonS3.UploadObject;

/// <summary>
/// Amazon S3 Task.
/// </summary>
public class AmazonS3
{
    /// <summary>
    /// Upload objects to AWS S3 Bucket.
    /// [Documentation](https://tasks.frends.com/tasks/frends-tasks/Frends.AmazonS3.UploadObject)
    /// </summary>
    /// <param name="input">Input parameters including source directory, file mask, target directory, bucket name, ACL settings, and upload options</param>
    /// <param name="connection">Connection parameters including authentication method, AWS credentials, region, and upload configuration</param>
    /// <param name="options">Options parameters for error handling including ThrowErrorIfNoMatch, FailOnErrorResponse, ThrowErrorOnFailure, and ErrorMessageOnFailure</param>
    /// <param name="cancellationToken">Token generated by Frends to stop this Task.</param>
    /// <returns>Object { bool Success, List&lt;string&gt; Objects, string DebugLog }</returns>
    public static async Task<Result> UploadObject([PropertyTab] Input input, [PropertyTab] Connection connection, [PropertyTab] Options options, CancellationToken cancellationToken)
    {
        if (!Directory.Exists(input.SourceDirectory)) throw new ArgumentException(@"Source directory not found. ", input.SourceDirectory);

        var localRoot = new DirectoryInfo(input.SourceDirectory);

        // If filemask is not set, get all files.
        var filesToCopy = localRoot.GetFiles(
            input.FileMask ?? "*",
            input.UploadFromCurrentDirectoryOnly ? SearchOption.TopDirectoryOnly : SearchOption.AllDirectories);

        if (options.ThrowErrorIfNoMatch && filesToCopy.Length < 1)
            throw new Exception($"No files match the filemask '{input.FileMask ?? "*"}' within supplied path.");

        var result = new List<string>();
        StringWriter sw = null;
        ILoggerFactory lf = null;
        var currentLoggingOption = AWSConfigs.LoggingConfig.LogTo;
        if (connection.GatherDebugLog)
        {
            sw = new StringWriter();
            lf = ConfigureAWSSDKLogging(sw);
        }
        else
        {
            AWSConfigs.LoggingConfig.LogTo = LoggingOptions.None;
        }

        try
        {
            foreach (var file in filesToCopy)
            {
                cancellationToken.ThrowIfCancellationRequested();

                if (file.FullName.Split(Path.DirectorySeparatorChar).Length >
                    input.SourceDirectory.Split(Path.DirectorySeparatorChar).Length && input.PreserveFolderStructure)
                {
                    var subfolders = file.FullName.Replace(file.Name, "")
                        .Replace(input.SourceDirectory.Replace(file.Name, ""), "").Replace(Path.DirectorySeparatorChar, '/');

                    if (subfolders.StartsWith('/'))
                        subfolders = subfolders.Remove(0, 1);

                    var fullPath = input.TargetDirectory + subfolders + file.Name;

                    if (connection.AuthenticationMethod is AuthenticationMethod.PreSignedUrl)
                        await UploadFilePreSignedUrl(connection, file.FullName, cancellationToken);
                    else
                    {
                        if (connection.UseMultipartUpload)
                            await UploadMultipart(file, connection, input, fullPath, cancellationToken);
                        else
                            await UploadFileToS3(file, connection, input, fullPath, cancellationToken);
                    }

                    result.Add(connection.ReturnListOfObjectKeys ? fullPath : file.FullName);
                }
                else
                {
                    if (connection.AuthenticationMethod is AuthenticationMethod.PreSignedUrl)
                        await UploadFilePreSignedUrl(connection, file.FullName, cancellationToken);
                    else
                    {
                        if (connection.UseMultipartUpload)
                            await UploadMultipart(file, connection, input, input.TargetDirectory + file.Name,
                                cancellationToken);
                        else
                            await UploadFileToS3(file, connection, input, input.TargetDirectory + file.Name,
                                cancellationToken);
                    }

                    result.Add(connection.ReturnListOfObjectKeys ? input.TargetDirectory + file.Name : file.FullName);
                }

                if (input.DeleteSource) DeleteSourceFile(file.FullName);

                // Each file require their own presigned URL so no point to loop more than first file.
                if (connection.AuthenticationMethod == AuthenticationMethod.PreSignedUrl) break;
            }

            return new Result(true, result, sw?.ToString());
        }
        catch (AmazonS3Exception ex)
        {
            var errorHandlerResult = ErrorHandler.Handle(ex, options);
            errorHandlerResult.DebugLog = connection.GatherDebugLog && sw != null
                ? sw.ToString()
                : $"Exception: {ex.Message}, InnerException: {ex.InnerException}";
            errorHandlerResult.Objects = result;
            return errorHandlerResult;
        }
        catch (Exception ex)
        {
            var errorHandlerResult = ErrorHandler.Handle(ex, options);
            errorHandlerResult.DebugLog = connection.GatherDebugLog && sw != null
                ? sw.ToString()
                : $"Exception: {ex.Message}, InnerException: {ex.InnerException}";
            errorHandlerResult.Objects = result;
            return errorHandlerResult;
        }
        finally
        {
            if (connection.GatherDebugLog)
            {
                UnconfigureAWSSDKLogging();
            }

            sw?.Dispose();
            lf?.Dispose();

            AWSConfigs.LoggingConfig.LogTo = currentLoggingOption;
        }
    }

    private static ILoggerFactory ConfigureAWSSDKLogging(StringWriter sw)
    {
        var lf = LoggerFactory.Create(builder =>
        {
            builder.AddProvider(new StringWriterLoggerProvider(sw));
        });
        lf.ConfigureAWSSDKLogging();
        return lf;
    }

    private static void UnconfigureAWSSDKLogging()
    {
        Amazon.Runtime.Logging.AdaptorLoggerFactoryRegistry.DeregisterAdaptorLoggerFactory("ILogger");
    }

    private static async Task UploadFilePreSignedUrl(Connection connection, string path, CancellationToken cancellationToken)
    {
        await using var fileStream = File.OpenRead(path);
        var fileStreamResponse = await new HttpClient().PutAsync(new Uri(connection.PreSignedUrl), new StreamContent(fileStream), cancellationToken);
        var response = fileStreamResponse.EnsureSuccessStatusCode();
    }

    private static async Task<PutObjectResponse> UploadFileToS3(FileInfo file, Connection connection, Input input, string path, CancellationToken cancellationToken)
    {
        PutObjectResponse result;
        using var client = new AmazonS3Client(connection.AwsAccessKeyId, connection.AwsSecretAccessKey, RegionSelection(connection.Region));
        if (!connection.Overwrite)
        {
            try
            {
                var request = new GetObjectRequest
                {
                    BucketName = input.BucketName,
                    Key = path,
                };
                await client.GetObjectAsync(request, cancellationToken);
                throw new ArgumentException($"Object {file.Name} already exists in S3 at {request.Key}. Set Overwrite-option to true to overwrite the existing file.");
            }
            //Move on if AmazonS3Exception is thrown.
            catch (AmazonS3Exception) { }
        }

        var putObjectRequest = new PutObjectRequest
        {
            BucketName = input.BucketName,
            Key = path,
            FilePath = file.FullName,
            CannedACL = (input.UseACL) ? GetS3CannedACL(input.ACL) : S3CannedACL.NoACL,
        };

        result = await client.PutObjectAsync(putObjectRequest, cancellationToken);

        return result;
    }

    private static async Task UploadMultipart(FileInfo file, Connection connection, Input input, string path, CancellationToken cancellationToken)
    {
        var uploadResponses = new List<UploadPartResponse>();

        InitiateMultipartUploadRequest initiateRequest = new()
        {
            BucketName = input.BucketName,
            Key = path,
        };

        using var client = new AmazonS3Client(connection.AwsAccessKeyId, connection.AwsSecretAccessKey, RegionSelection(connection.Region));
        var initResponse = await client.InitiateMultipartUploadAsync(initiateRequest, cancellationToken);

        long partSizeInBytes = input.PartSize * (long)Math.Pow(2, 20);
        UploadPartRequest uploadRequest = null;
        try
        {
            long filePosition = 0;
            for (int i = 1; filePosition < file.Length; i++)
            {
                uploadRequest = new()
                {
                    BucketName = input.BucketName,
                    Key = path,
                    UploadId = initResponse.UploadId,
                    PartNumber = i,
                    PartSize = partSizeInBytes,
                    FilePosition = filePosition,
                    FilePath = file.FullName,
                };

                uploadResponses.Add(await client.UploadPartAsync(uploadRequest, cancellationToken));

                filePosition += partSizeInBytes;
            }

            CompleteMultipartUploadRequest completeRequest = new()
            {
                BucketName = input.BucketName,
                Key = path,
                UploadId = initResponse.UploadId
            };
            completeRequest.AddPartETags(uploadResponses);

            var completeUploadResponse = await client.CompleteMultipartUploadAsync(completeRequest, cancellationToken);
        }
        catch (Exception)
        {
            ListPartsRequest listPartsRequest = new()
            {
                UploadId = uploadRequest.UploadId
            };

            var listParts = await client.ListPartsAsync(listPartsRequest, cancellationToken);

            while (listParts.Parts.Count > 0)
            {
                foreach (var part in listParts.Parts)
                {
                    AbortMultipartUploadRequest abortMPURequest = new()
                    {
                        BucketName = input.BucketName,
                        Key = path,
                        UploadId = uploadRequest.UploadId
                    };
                    await client.AbortMultipartUploadAsync(abortMPURequest, cancellationToken);
                }

                listParts = await client.ListPartsAsync(listPartsRequest, cancellationToken);
            }
        }
    }

    private static void DeleteSourceFile(string filePath)
    {
        try
        {
            var file = new FileInfo(filePath);
            while (IsFileLocked(file)) Thread.Sleep(1000);
            File.Delete(filePath);
        }
        catch (Exception ex) { throw new Exception($"Delete failed. ", ex); }
    }

    private static bool IsFileLocked(FileInfo file)
    {
        FileStream stream = null;

        try
        {
            stream = file.Open(FileMode.Open, FileAccess.ReadWrite, FileShare.None);
        }
        catch (IOException)
        {
            // The file is unavailable because it is:
            // 1. Still being written to.
            // 2. Being processed by another thread.
            // 3. Does not exist (has already been processed).
            return true;
        }
        finally { stream?.Close(); }

        // File is not locked.
        return false;
    }

    private static S3CannedACL GetS3CannedACL(ACLs acl)
    {
        return acl switch
        {
            ACLs.Private => S3CannedACL.Private,
            ACLs.PublicRead => S3CannedACL.PublicRead,
            ACLs.PublicReadWrite => S3CannedACL.PublicReadWrite,
            ACLs.AuthenticatedRead => S3CannedACL.AuthenticatedRead,
            ACLs.BucketOwnerRead => S3CannedACL.BucketOwnerRead,
            ACLs.BucketOwnerFullControl => S3CannedACL.BucketOwnerFullControl,
            ACLs.LogDeliveryWrite => S3CannedACL.LogDeliveryWrite,
            _ => S3CannedACL.NoACL,
        };
    }

    [ExcludeFromCodeCoverage(Justification = "Only able to test EU central 1.")]
    private static RegionEndpoint RegionSelection(Region region)
    {
        return region switch
        {
            Region.AfSouth1 => RegionEndpoint.AFSouth1,
            Region.ApEast1 => RegionEndpoint.APEast1,
            Region.ApNortheast1 => RegionEndpoint.APNortheast1,
            Region.ApNortheast2 => RegionEndpoint.APNortheast2,
            Region.ApNortheast3 => RegionEndpoint.APNortheast3,
            Region.ApSouth1 => RegionEndpoint.APSouth1,
            Region.ApSoutheast1 => RegionEndpoint.APSoutheast1,
            Region.ApSoutheast2 => RegionEndpoint.APSoutheast2,
            Region.CaCentral1 => RegionEndpoint.CACentral1,
            Region.CnNorth1 => RegionEndpoint.CNNorth1,
            Region.CnNorthWest1 => RegionEndpoint.CNNorthWest1,
            Region.EuCentral1 => RegionEndpoint.EUCentral1,
            Region.EuNorth1 => RegionEndpoint.EUNorth1,
            Region.EuSouth1 => RegionEndpoint.EUSouth1,
            Region.EuWest1 => RegionEndpoint.EUWest1,
            Region.EuWest2 => RegionEndpoint.EUWest2,
            Region.EuWest3 => RegionEndpoint.EUWest3,
            Region.MeSouth1 => RegionEndpoint.MESouth1,
            Region.SaEast1 => RegionEndpoint.SAEast1,
            Region.UsEast1 => RegionEndpoint.USEast1,
            Region.UsEast2 => RegionEndpoint.USEast2,
            Region.UsWest1 => RegionEndpoint.USWest1,
            Region.UsWest2 => RegionEndpoint.USWest2,
            _ => RegionEndpoint.EUWest1,
        };
    }
}
